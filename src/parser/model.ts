import { ILexer } from "../lexer";
import { Logger } from "../model";
import { ASTNode } from "./ast";

export type AcceptedParserOutput<T, Kinds extends string> = {
  accept: true;
  /**
   * Current AST nodes.
   */
  buffer: readonly ASTNode<T, Kinds>[];
  /**
   * Newly generated AST nodes by the current parsing call with error.
   * Empty list if no error generated by the current parsing call.
   */
  errors: readonly ASTNode<T, Kinds>[];
};

export const rejectedParserOutput = Object.freeze({ accept: false });
export type RejectedParserOutput = typeof rejectedParserOutput;

export type ParserOutput<T, Kinds extends string> =
  | RejectedParserOutput
  | AcceptedParserOutput<T, Kinds>;

/**
 * The `input` will be fed to the lexer.
 */
export type ParseExec<T, Kinds extends string> = (
  input?:
    | string
    | {
        input?: string;
        /**
         * Stop parsing when the first error is generated.
         * Be ware, this might cause inconsistent buffer state.
         *
         * Default: `false`.
         */
        stopOnError?: boolean;
      }
) => ParserOutput<T, Kinds>;

// TODO: default T
export interface IParser<T, Kinds extends string> {
  /**
   * When `debug` is `true`, the parser will use `logger` to log debug info.
   * Default: `false`.
   */
  debug: boolean;
  /**
   * The logger used when `debug` is `true`.
   * Default: `console.log`.
   */
  logger: Logger;
  readonly lexer: ILexer<any, Kinds>;
  /**
   * Reset state.
   */
  reset(): this;
  /**
   * Clone a new parser with the same states.
   */
  clone(options?: { debug?: boolean; logger?: Logger }): IParser<T, Kinds>;
  /**
   * Clone a new parser without states.
   */
  dryClone(options?: { debug?: boolean; logger?: Logger }): IParser<T, Kinds>;
  /**
   * Feed a string to the lexer.
   */
  feed(input: string): this;
  /**
   * Try to yield an entry NT.
   * Stop when the first entry NT is reduced.
   */
  readonly parse: ParseExec<T, Kinds>;
  /**
   * Try to reduce till the parser can't accept more.
   * This is useful if your entry NT can also be reduced by other rules.
   */
  readonly parseAll: ParseExec<T, Kinds>;
  /**
   * Get error AST nodes.
   */
  getErrors(): readonly ASTNode<T, Kinds>[]; // TODO: use getter
  hasErrors(): boolean;
  /**
   * Current AST nodes.
   */
  getNodes(): readonly ASTNode<T, Kinds>[]; // TODO: rename to buffer, use getter
  /**
   * Take the first AST node.
   */
  take(): ASTNode<T, Kinds> | undefined; // TODO: take N
}
