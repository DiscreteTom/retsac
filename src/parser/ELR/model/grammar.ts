import { ASTNode, Traverser } from "../../ast";
import { TempGrammarRule } from "../builder";
import { StringCache, Cache } from "../../cache";
import { Conflict, ResolvedConflict } from "./conflict";
import { Callback, Condition } from "./context";
import { ruleEndsWith, ruleStartsWith } from "./util";
import { Candidate } from "../DFA/candidate";
import { State } from "../DFA/state";

export enum GrammarType {
  /**
   * Terminator, which means the grammar's kind name should be defined in lexer.
   */
  T,
  /**
   * Non-terminator, which means the grammar's kind name should be defined in parser.
   */
  NT,
}

export class Grammar {
  readonly type: GrammarType;
  /**
   * The kind name.
   */
  readonly kind: string;
  /**
   * The literal value if this is a T and require the text to match, without quote.
   * @default undefined
   */
  readonly text?: string;
  /**
   * The name of the grammar.
   * By default it's the same as the {@link Grammar.kind kind} name.
   */
  readonly name: string;

  /**
   * For debug output.
   */
  readonly str: StringCache;
  /**
   * A unique key for cache.
   * This is used in {@link Candidate.getNext} and {@link State.getNext}.
   */
  // TODO: rename this to some `nodeMatcher`?
  readonly cacheKeyWithoutName: StringCache;
  /**
   * @see ASTNode.strWithName
   */
  readonly strWithName: StringCache;
  /**
   * @see ASTNode.strWithoutName
   */
  readonly strWithoutName: StringCache;
  /**
   * Format: `kind@name` if not literal, else `"text"@name`.
   * This is used to generate grammar rule string with name.
   */
  readonly grammarStrWithName: string;
  /**
   * Format: `kind` if not literal, else `"text"`.
   */
  readonly grammarStrWithoutName: StringCache;
  /**
   * This is used when calculate all DFA state.
   */
  readonly mockNode: Cache<Readonly<ASTNode<any, any>>>;

  /**
   * Only {@link GrammarRepo} should use this constructor.
   */
  constructor(
    p: Pick<Grammar, "type" | "kind" | "name" | "text"> & {
      /**
       * Reuse this generated by {@link GrammarRepo}.
       */
      grammarStrWithName: string;
    }
  ) {
    this.type = p.type;
    this.kind = p.kind;
    this.name = p.name;
    this.text = p.text;

    this.str = new StringCache(
      () =>
        `Grammar({ type: "${GrammarType[this.type]}", kind: "${
          this.kind
        }", name: "${this.name}", text: ${JSON.stringify(this.text)} })` // quote text, escape literal
    );
    this.cacheKeyWithoutName = new StringCache(() =>
      Grammar.getCacheKeyWithoutName(this)
    );
    this.strWithName = new StringCache(() => ASTNode.getStrWithName(this));
    this.strWithoutName = new StringCache(() =>
      ASTNode.getStrWithoutName(this)
    );
    this.grammarStrWithName = p.grammarStrWithName;
    this.grammarStrWithoutName = new StringCache(() =>
      Grammar.getGrammarStrWithoutName(this)
    );
    this.mockNode = new Cache(
      () =>
        new ASTNode({
          kind: this.kind,
          text: this.text,
          start: 0,
          // don't set name, since the name is set by the parent node
        })
    );
  }

  /**
   * This is used in conflict detection, so we don't need to check the name.
   * This is required because some grammar's names are different, but the kind & text are the same.
   */
  equalWithoutName(g: Readonly<Grammar>) {
    return (
      this == g || // same object
      (this.type == g.type && this.kind == g.kind && this.text == g.text)
    );
  }

  /**
   * Check if the grammar's kind match the {@link ASTNode.kind}.
   * Also check the text if `this.text` is not `undefined`.
   */
  match(node: Readonly<ASTNode<any, any>>) {
    // we don't need to check the name
    // because the name is set by the grammar after the grammar is matched
    return (
      this.kind == node.kind &&
      (this.text == undefined || this.text == node.text)
    );
  }

  /**
   * @see Grammar.str
   */
  toString() {
    return this.str.value;
  }

  /**
   * @see Grammar.cacheKeyWithoutName
   */
  static getCacheKeyWithoutName(data: Pick<Grammar, "kind" | "text">): string {
    // when current is literal, in Grammar.match we will check the kind and text
    // so we need to use both kind and text to calculate cache key
    if (data.text != undefined) {
      return `${data.kind}:${data.text}`;
    }

    // else, if this is NT, we only need the kind name as the cache.
    // if this is a T without
    return data.kind;
  }

  /**
   * @see Grammar.grammarStrWithName
   */
  static getGrammarStrWithName(data: Pick<Grammar, "kind" | "name" | "text">) {
    return (
      (data.text != undefined
        ? JSON.stringify(data.text) // quote text, escape literal
        : data.kind) + (data.name == data.kind ? "" : "@" + data.name)
    );
  }

  /**
   * @see Grammar.grammarStrWithoutName
   */
  static getGrammarStrWithoutName(data: Pick<Grammar, "kind" | "text">) {
    return data.text != undefined
      ? JSON.stringify(data.text) // quote text, escape literal
      : data.kind;
  }

  toSerializable() {
    return {
      type: this.type,
      kind: this.kind,
      name: this.name,
      text: this.text,
      str: this.str.value,
      cacheKeyWithoutName: this.cacheKeyWithoutName.value,
      strWithName: this.strWithName.value,
      strWithoutName: this.strWithoutName.value,
      grammarStrWithName: this.grammarStrWithName,
      grammarStrWithoutName: this.grammarStrWithoutName.value,
    };
  }
}

export class GrammarRule<ASTData, Kinds extends string> {
  readonly rule: readonly Grammar[];
  /**
   * The reduce target's kind name.
   */
  readonly NT: Kinds;
  /**
   * A list of conflicts when the grammar rule wants to reduce.
   * All conflicts must be resolved before the DFA can be built.
   * This will NOT be evaluated during parsing, just to record conflicts.
   */
  readonly conflicts: Conflict<ASTData, Kinds>[];
  /**
   * A list of resolved conflicts.
   * All conflicts must be resolved by this before the DFA can be built.
   * This will be evaluated by candidate during parsing.
   */
  readonly resolved: ResolvedConflict<ASTData, Kinds>[];
  callback?: Callback<ASTData, Kinds>;
  rejecter?: Condition<ASTData, Kinds>;
  rollback?: Callback<ASTData, Kinds>;
  commit?: Condition<ASTData, Kinds>;
  traverser?: Traverser<ASTData, Kinds>;

  /**
   * For debug output.
   */
  readonly str: StringCache;
  /**
   * Return ``{ NT: `grammar rules with name` }``.
   */
  readonly strWithGrammarName: StringCache;
  /**
   * Return ``{ NT: `grammar rules without name` }``.
   */
  readonly strWithoutGrammarName: StringCache;

  constructor(
    p: Pick<
      GrammarRule<ASTData, Kinds>,
      | "rule"
      | "NT"
      | "callback"
      | "rejecter"
      | "rollback"
      | "commit"
      | "traverser"
    >
  ) {
    this.rule = p.rule;
    this.NT = p.NT;
    this.callback = p.callback;
    this.rejecter = p.rejecter;
    this.rollback = p.rollback;
    this.commit = p.commit;
    this.traverser = p.traverser;
    this.conflicts = [];
    this.resolved = [];

    this.str = new StringCache(() => this.strWithGrammarName.value);
    this.strWithGrammarName = new StringCache(() =>
      GrammarRule.getStrWithGrammarName(this)
    );
    this.strWithoutGrammarName = new StringCache(() =>
      GrammarRule.getStrWithoutGrammarName(this)
    );
  }

  /**
   * Check if the tail of this's rule is the same as the head of another.
   * Which means this rule want's to reduce, and another rule want's to shift.
   */
  checkRSConflict(another: Readonly<GrammarRule<ASTData, Kinds>>) {
    const result = [] as {
      shifterRule: Pick<Conflict<ASTData, Kinds>, "anotherRule">["anotherRule"];
      overlapped: Extract<
        Pick<Conflict<ASTData, Kinds>, "overlapped">["overlapped"],
        number
      >;
    }[];
    for (let i = 0; i < this.rule.length; ++i) {
      if (
        ruleStartsWith(another.rule, this.rule.slice(i)) &&
        // if the tail of this rule is the same as another's whole rule, it's a reduce-reduce conflict.
        // e.g. `A B C | B C`
        this.rule.length - i != another.rule.length
      ) {
        result.push({
          shifterRule: another,
          overlapped: this.rule.length - i,
        });
      }
    }
    return result;
  }

  /**
   * Check if the tail of this's rule is the same as another's whole rule.
   */
  checkRRConflict(another: Readonly<GrammarRule<ASTData, Kinds>>) {
    return ruleEndsWith(this.rule, another.rule);
  }

  /**
   * @see GrammarRule.str
   */
  toString() {
    return this.str.value;
  }

  /**
   * @see GrammarRule.strWithGrammarName
   */
  static getStrWithGrammarName(gr: Pick<GrammarRule<any, any>, "NT" | "rule">) {
    return `{ ${gr.NT}: \`${gr.rule
      .map((g) => g.grammarStrWithName)
      .join(" ")}\` }`;
  }

  /**
   * @see GrammarRule.strWithoutGrammarName
   */
  static getStrWithoutGrammarName(
    gr: Pick<GrammarRule<any, any>, "NT" | "rule">
  ) {
    return `{ ${gr.NT}: \`${gr.rule
      .map((g) => g.grammarStrWithoutName.value)
      .join(" ")}\` }`;
  }

  toSerializable() {
    // TODO: type this
    return {
      key: this.strWithGrammarName.value,
      NT: this.NT,
      rule: this.rule.map((g) => g.toSerializable()),
      conflicts: this.conflicts.map((c) => ({
        type: c.type,
        anotherRule: c.anotherRule.strWithGrammarName.value,
        next: c.next.map((g) => g.toSerializable()),
        handleEnd: c.handleEnd,
        overlapped: c.overlapped,
      })),
      resolved: this.resolved.map((r) => ({
        type: r.type,
        anotherRule: r.anotherRule.strWithGrammarName.value,
        handleEnd: r.handleEnd,
        next: r.next == "*" ? "*" : r.next.map((g) => g.toSerializable()),
        // accepter
      })),
    };
  }
}

/**
 * A set of different grammars, ignore the name.
 * This is used when the name of grammar is NOT needed.
 * E.g. DFA's first/follow sets.
 */
export class GrammarSet {
  /**
   * Grammars. {@link Grammar.strWithoutName} => grammar
   */
  private gs: Map<string, Grammar>;

  constructor() {
    this.gs = new Map();
  }

  get grammars() {
    return this.gs as ReadonlyMap<string, Grammar>;
  }

  /**
   * Return `true` if successfully added(g is not in this before), else `false`.
   */
  add(g: Grammar) {
    if (this.has(g)) return false;
    this.gs.set(g.strWithoutName.value, g);
    return true;
  }

  has(g: Readonly<Grammar> | Readonly<ASTNode<any, any>>) {
    return this.gs.has(g.strWithoutName.value); // Grammar & ASTNode has the same string format
  }

  map<T>(callback: (g: Grammar) => T) {
    const res = [] as T[];
    this.gs.forEach((g) => res.push(callback(g)));
    return res;
  }

  /**
   * Return a list of grammars that in both `this` and `gs`.
   */
  overlap(gs: Readonly<GrammarSet>) {
    const result = [] as Grammar[];
    this.gs.forEach((g) => {
      if (gs.has(g)) result.push(g);
    });
    return result;
  }

  toSerializable() {
    return this.map((g) => g.toSerializable());
  }
}

/**
 * A set of different grammars, include the name.
 * This is used to manage the creation of grammars, to prevent creating the same grammar twice.
 */
export class GrammarRepo {
  /**
   * Grammars. {@link Grammar.getGrammarStrWithName} => grammar
   */
  private gs: Map<string, Grammar>;

  constructor() {
    this.gs = new Map();
  }

  private getByString(str: string) {
    return this.gs.get(str);
  }

  get(data: Pick<Grammar, "kind" | "name" | "text">) {
    return this.getByString(Grammar.getGrammarStrWithName(data));
  }

  /**
   * Get or create a T grammar.
   */
  T(kind: string, name?: string) {
    name = name ?? kind;
    const str = Grammar.getGrammarStrWithName({ kind, name });
    const res = this.getByString(str);
    if (res !== undefined) return res;

    const g = new Grammar({
      type: GrammarType.T,
      kind,
      name,
      grammarStrWithName: str,
    });
    this.gs.set(str, g);
    return g;
  }

  /**
   * Get or create a NT grammar.
   */
  NT(kind: string, name?: string) {
    name = name ?? kind;
    const str = Grammar.getGrammarStrWithName({ kind, name });
    const res = this.getByString(str);
    if (res !== undefined) return res;

    const g = new Grammar({
      type: GrammarType.NT,
      kind,
      name,
      grammarStrWithName: str,
    });
    this.gs.set(str, g);
    return g;
  }

  /**
   * Get or create a T grammar with text.
   */
  Literal(text: string, kind: string, name?: string) {
    name = name ?? kind;
    const str = Grammar.getGrammarStrWithName({ kind, name, text });
    const res = this.getByString(str);
    if (res !== undefined) return res;

    const g = new Grammar({
      type: GrammarType.T,
      kind,
      name,
      text,
      grammarStrWithName: str,
    });
    this.gs.set(str, g);
    return g;
  }

  toSerializable() {
    const result = [] as any[];
    return this.gs.forEach((g) => result.push(g.toSerializable()));
  }
}

/**
 * A set of different grammar rules, grammar's name will be included.
 * This is used to manage the creation of grammar rules, to prevent creating the same grammar rule twice.
 */
export class GrammarRuleRepo<ASTData, Kinds extends string> {
  /**
   * {@link GrammarRule.strWithGrammarName} => grammar rule
   */
  readonly grammarRules: ReadonlyMap<string, GrammarRule<ASTData, Kinds>>;

  constructor(grs: readonly GrammarRule<ASTData, Kinds>[]) {
    const map = new Map();
    grs.forEach((gr) => map.set(gr.strWithGrammarName.value, gr));
    this.grammarRules = map;
  }

  get(gr: TempGrammarRule<any, any>) {
    return this.grammarRules.get(gr.toStringWithGrammarName());
  }

  map<R>(callback: (g: GrammarRule<ASTData, Kinds>) => R) {
    const res = [] as R[];
    this.grammarRules.forEach((gr) => res.push(callback(gr)));
    return res;
  }

  filter(callback: (g: GrammarRule<ASTData, Kinds>) => boolean) {
    const res = [] as GrammarRule<ASTData, Kinds>[];
    this.grammarRules.forEach((gr) => {
      if (callback(gr)) res.push(gr);
    });
    return res;
  }

  toSerializable() {
    return this.map((gr) => gr.toSerializable());
  }
}
