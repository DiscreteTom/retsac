import type { AcceptedActionDecoratorContext } from "../../action";
import { Action } from "../../action";
import type {
  EscapeHandler,
  StringLiteralData as CommonStringLiteralData,
  EscapeInfo,
} from "../string";
import { stringLiteral as commonStringLiteral } from "../string";
import { fallback, map, unicode } from "../string/handler";

export const escapeHandlerFactory = {
  /**
   * Handle JSON's simple escapes.
   * ```
   * { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "\t" }
   * ```
   */
  simple(): EscapeHandler<never> {
    // ref: https://www.json.org/json-en.html
    return map({
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "\t",
    });
  },
} as const;

export const escapeHandlers = [
  escapeHandlerFactory.simple(),
  unicode({ error: "unicode" }),
  // keep the fallback handler at the end for error handling
  fallback({ error: "unnecessary" }),
] as const;

export type StringLiteralData<EscapeErrorKinds extends string> = {
  /**
   * `undefined` if the string literal is valid.
   */
  invalid?: {
    escapes: EscapeInfo<EscapeErrorKinds>[];
    /**
     * The index of the whole input string where the invalid characters (control characters, char code < 0x20) are located.
     */
    chars: number[];
  } & Pick<CommonStringLiteralData<EscapeErrorKinds>, "unclosed">;
} & Pick<CommonStringLiteralData<EscapeErrorKinds>, "value" | "escapes">;

/**
 * Transform {@link CommonStringLiteralData} to {@link StringLiteralData}.
 */
export function stringLiteralDataMapper<
  EscapeErrorKinds extends string,
  ActionState,
  ErrorType,
>({
  input: _,
  output,
}: AcceptedActionDecoratorContext<
  { kind: never; data: CommonStringLiteralData<EscapeErrorKinds> },
  ActionState,
  ErrorType
>): StringLiteralData<EscapeErrorKinds> {
  const invalid: NonNullable<StringLiteralData<EscapeErrorKinds>["invalid"]> = {
    unclosed: output.data.unclosed,
    escapes: output.data.escapes.filter((e) => e.error !== undefined),
    chars: new Array(output.content.length)
      .fill(0)
      .map((_, i) => (output.content.charCodeAt(i) < 0x20 ? i : -1))
      .filter((i) => i !== -1),
  };

  return {
    value: output.data.value,
    escapes: output.data.escapes,
    invalid:
      invalid.unclosed || invalid.escapes.length > 0 || invalid.chars.length > 0
        ? invalid
        : undefined,
  };
}

/**
 * Match a JSON string literal, with error handling.
 */
export function stringLiteral<ActionState = never, ErrorType = never>(): Action<
  {
    kind: never;
    data: StringLiteralData<
      "unicode" | "unnecessary" | "unterminated" | "unhandled"
    >;
  },
  ActionState,
  ErrorType
> {
  return commonStringLiteral<"unicode" | "unnecessary", ActionState, ErrorType>(
    `"`,
    { escape: { handlers: escapeHandlers } },
  ).data(stringLiteralDataMapper);
}

/**
 * Match a JSON string literal, with NO error handling.
 *
 * To get the value of the string literal, use `Lexer.javascript.evalString`.
 */
export function exactStringLiteral<
  ActionState = never,
  ErrorType = never,
>(): Action<{ kind: never; data: undefined }, ActionState, ErrorType> {
  return Action.dryMatch<ActionState, ErrorType>(
    // ref: https://www.json.org/json-en.html
    // import { compose } from "@discretetom/r-compose";
    // compose((c) =>
    //   c.concat(
    //     '"', // the open quote
    //     c.any(
    //       c.select(
    //         // any character except control characters, double quote and backslash
    //         /[\x20\x21\x23-\x5b\x5d-\u{10FFFF}]/,
    //         // escape sequences
    //         c.concat(
    //           /\\/,
    //           c.select(
    //             // simple escapes
    //             ...`"\\/bfnrt`.split("").map(c.escape),
    //             // unicode escape
    //             /u[0-9a-fA-F]{4}/,
    //           ),
    //         ),
    //       ),
    //     ),
    //     '"', // the close quote
    //   ),
    // ),
    // generated by the above code
    /"(?:(?:[\x20\x21\x23-\x5b\x5d-\u{10FFFF}]|\\(?:"|\\|\/|b|f|n|r|t|u[0-9a-fA-F]{4})))*"/,
  );
}
