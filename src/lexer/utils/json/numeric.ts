import { tryOrDefault } from "../../../try";
import type { AcceptedActionDecoratorContext } from "../../action";
import { Action } from "../../action";
import type { NumericLiteralData as CommonNumericLiteralData } from "../numeric";
import { numericLiteral as commonNumericLiteral } from "../numeric";

export type NumericLiteralData = {
  /**
   * The value of the numeric literal.
   * This will try to be parsed even if the numeric literal is invalid.
   */
  value: number | bigint;
  /**
   * `undefined` if the numeric literal valid.
   */
  invalid?: {
    /**
     * If `true`, the integer part is empty.
     */
    emptyInteger: boolean;
    /**
     * If `true`, the decimal point is provided but the fraction content is empty.
     */
    emptyFraction: boolean;
    /**
     * If `true`, the exponent identifier is provided but the exponent content is empty.
     */
    emptyExponent: boolean;
    /**
     * If `true`, the integer part starts with `0` but is not `0`.
     */
    leadingZero: boolean;
  };
} & CommonNumericLiteralData;

/**
 * Transform {@link CommonNumericLiteralData} to {@link NumericLiteralData}.
 */
export function numericLiteralDataMapper<ActionState, ErrorType>({
  input: _,
  output,
}: AcceptedActionDecoratorContext<
  { kind: never; data: CommonNumericLiteralData },
  ActionState,
  ErrorType
>): NumericLiteralData {
  const invalid: NonNullable<NumericLiteralData["invalid"]> = {
    emptyInteger: output.data.integer.body.length === 0,
    emptyFraction:
      output.data.fraction !== undefined &&
      output.data.fraction.body.length === 0,
    emptyExponent:
      output.data.exponent !== undefined &&
      output.data.exponent.body.length === 0,
    leadingZero:
      output.data.integer.body.length > 1 &&
      output.data.integer.body.startsWith("0"),
  };

  return {
    value: tryOrDefault(
      () =>
        Number(
          output.data.integer.body +
            output.data.fraction?.point.content +
            output.data.fraction?.body +
            output.data.exponent?.indicator.content +
            output.data.exponent?.body,
        ),
      0,
    ),
    invalid:
      invalid.emptyInteger ||
      invalid.emptyFraction ||
      invalid.emptyExponent ||
      invalid.leadingZero
        ? invalid
        : undefined,
    ...output.data,
  };
}

/**
 * Match a JSON numeric literal, with error handling.
 */
export function numericLiteral<
  ActionState = never,
  ErrorType = never,
>(): Action<{ kind: never; data: NumericLiteralData }, ActionState, ErrorType> {
  return commonNumericLiteral<ActionState, ErrorType>({
    prefix: /-?/,
    decimalPoint: ".",
    exponentIndicator: /[eE](?:[+-])?/,
  }).data(numericLiteralDataMapper);
}

/**
 * Match a JSON numeric literal, with NO error handling.
 */
export function exactNumericLiteral<
  ActionState = never,
  ErrorType = never,
>(): Action<{ kind: never; data: undefined }, ActionState, ErrorType> {
  return Action.dryMatch<ActionState, ErrorType>(
    // ref: https://www.json.org/json-en.html
    // import { compose } from "@discretetom/r-compose";
    // compose((c) =>
    //   c.concat(
    //     /-?/, // optional leading sign
    //     c.select(/0/, /[1-9][0-9]*/), // integer part
    //     c.optional(c.concat(".", /[0-9]+/)), // fraction part
    //     c.optional(c.concat(/[eE]/, c.optional(/[+-]/), /[0-9]+/)), // exponent part
    //   ),
    // ),
    // generated by the above code
    /-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?(?:[eE](?:[+-])?[0-9]+)?/,
  );
}
